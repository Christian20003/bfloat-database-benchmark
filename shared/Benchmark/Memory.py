import os
import sys

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../Print')))
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../Helper')))

from typing import Tuple, List
from pathlib import Path
from datetime import datetime
from threading import Thread, Event
import subprocess
import Format
import re
import Helper
import time
import psutil

def parse_heaptrack_output(file_name: str, source_file: str) -> Tuple[float, float]:
    '''
    This function executes the Heaptrack analysis tool and extracts the RSS memory and heap peak
    from the provided file. Ensure that the provided file is generated from Heaptrack, otherwise
    the tool will print an error.

    :param file_name: The name of the file in which the analysis tool should write its output.
    :param source_file: The name of the file generated by Heaptrack while tracking the memory 
    consumption of a process.
    
    :returns: A tuple including the used peak heap and RSS memory in GB of the process.
    '''

    # Check which type of file Heaptrack has generated (both are valid)
    data_file = f'./{source_file}.zst'
    if not Path(f'{source_file}.zst').exists():
        data_file = f'./{source_file}.gz'
    heap = 0
    rss = 0
    with open(file_name, 'w+') as file:
        # Start the analysis tool (flags ensure that only necessary content will be written in file)
        analyze = subprocess.Popen(
            ['heaptrack', '-a', '-p', '0', '-a', '0', '-T', '0', '-l', '0', data_file],
            stdout=file
        )
        analyze.communicate()
        file.seek(0)
        # Read the result of the analysis tool and extract heap and RSS value
        for item in file.readlines():
            if 'peak heap memory consumption' in item or 'peak RSS (including heaptrack overhead)' in item:
                index = item.find(':')
                value = item[index+1:]
                number = float(re.findall(r'-?\d+\.\d+e[+-]?\d+|-?\d+\.\d+|-?\d+', value)[0])
                if 'B' in value:
                    number = number / (1024*1024*1024)
                if 'K' in value:
                    number = number / (1024*1024)
                if 'M' in value:
                    number = number / 1024
                
                if 'heap memory' in item:
                    heap = number
                else:
                    rss = number
    return heap, rss

def heaptrack_memory(execution: str, file_name: str, statement: str = None, keep_raw_file: bool = False) -> Tuple[float, float]:
    '''
    This function executes a memory benchmark with Heaptrack.

    :param execution: The execution string of the database. This can include an SQL file that the database should execute. 
    If not, be sure to pass the SQL query in the `statement` parameter.
    :param file_name: The name of the file in which the analysis tool of Heaptrack should write its output.
    This name should makes the file unqiue from other files generated by the same tool.
    :param optional statement: The SQL query that should be executed by the database. Only use this parameter if the 
    `execution` parameter does not already reference to the query within a file.
    :param optional keep_raw_file: Heaptrack will create a file during memory measurement that includes important 
    information for the analysis tool. By default this file will be deleted after the analysis, but you can keep it setting this parameter to `True`.

    :returns: A tuple including the used peak heap and RSS memory in GB of the process.
    '''

    Format.print_information('Start the memory benchmark - This will take some time', mark=True)
    # Add a date to the file name
    date = datetime.now()
    formatted_date = date.strftime('%d-%m-%Y-%H-%M')
    file_name_raw = f'{formatted_date}-{file_name}-raw'
    file_name_analysed = f'{formatted_date}-{file_name}-analysed'
    # Start process for memory measurement
    database  = subprocess.Popen(
        ['heaptrack', '-o', file_name_raw] + execution.split(),
        stdin=subprocess.PIPE,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
        text=True
    )
    # Send sql query if not already set in execution string
    if statement:
        statement = statement.replace('\n', ' ')
        time.sleep(1)
        database.stdin.write(statement)
        database.stdin.flush()
    _, error = database.communicate()
    if error:
        Format.print_error('An error has been printed during memory benchmark', error)
    # Extract values and delete the raw file
    heap, rss = parse_heaptrack_output(file_name_analysed, file_name_raw)
    if not keep_raw_file:
        Helper.remove_files([f'{file_name_raw}.zst', f'{file_name_raw}.gz'])
    return heap, rss

def memory_thread(life_signal: Event, process_signal: Event, file_name: str, used_memory: float, sleep: float) -> None:
    '''
    This function is a thread that reads the memory consumption of a process and writes it into a file.

    :param life_signal: If the thread should be active.
    :param process_signal: If the process is active and memory should be read.
    :param file_name: The name of the file in which to write the memory values.
    :param used_memory: The memory consumption before the activation of the process (in bytes).
    :param sleep: The time the thread should sleep between two measurements (in seconds).
    '''

    with open(file_name, 'w') as file:
        while life_signal.is_set():
            if not process_signal.is_set():
                continue
            try:
                memory = psutil.virtual_memory()
                file.write(str(memory.used - used_memory) + '\n')
                time.sleep(sleep)
            except psutil.NoSuchProcess:
                Format.print_error('Psutil-Thread did not find process', None)
                break

def python_memory(execution: str, time: float, statement: str = None, memory_over_time: bool = False) -> List[float]:
    '''
    This function executes a memory benchmark with python by using the Psutil module.

    :param execution: The execution string of the database. This can include an SQL file that the database should execute. 
    If not, be sure to pass the SQL query in the `statement` parameter.
    :param time: The execution time of the process. This is used to determine how often the memory should be read.
    :param optional statement: The SQL query that should be executed by the database. Only use this parameter if the 
    `execution` parameter does not already reference to the query within a file.
    :param memory_over_time: If a list of memory values should be returned representing the development of the memory
    over time, otherwise only the peak is returned.

    :returns: The peak memory consumption of the process if `memory_over_time` is `False`, otherwise a list
    of multiple memory values (everything in bytes).
    '''

    Format.print_information('Start the memory benchmark - This will take some time', mark=True)
    # Setup the memory measurement
    life_signal = Event()
    process_signal = Event()
    life_signal.set()
    file_name = 'memory_data'
    result = []
    # Sleep time is only necessary for long running processes to reduce the overhead
    sleep = 0.001 if time > 60 or memory_over_time else 0
    current_memory = psutil.virtual_memory().used
    thread = Thread(target=memory_thread, args=(life_signal, process_signal, file_name, current_memory, sleep))
    thread.start()

    # Start the process that should be measured
    database = subprocess.Popen(
        execution.split(),
        stdin=subprocess.PIPE,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
        text=True
    )
    # Let the thread know that the process is running
    process_signal.set()
    # Send sql query if not already set in execution string
    if statement:
        statement = statement.replace('\n', ' ')
        time.sleep(0.5)
        database.stdin.write(statement)
        database.stdin.flush()
    _, error = database.communicate()
    life_signal.clear()
    if error:
        Format.print_error('An error has been printed during memory benchmark', error)
    thread.join()

    # Read the memory values from the file and delete it afterwards
    with open(file_name, 'r') as file:
        data = [float(value) for value in file.readlines()]
        if memory_over_time:
            result = data
        else:
            result.append(max(data))
    Helper.remove_files([file_name])
    return result